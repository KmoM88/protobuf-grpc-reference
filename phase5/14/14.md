# Chapter 14: Internals (Under the Hood)
To achieve its efficiency and forward/backward compatibility, Protobuf uses highly optimized binary encoding techniques. Understanding the wire format is key to appreciating why Protobuf is compact and fast.

## 14.1. Wire Format: Understanding Base 128 Varints.
Varints (Variable-length Integers) are Protobuf's primary method for encoding integers (and the field tag/wire type combination). They allow small numbers to take up less space than large numbers.
- Mechanism: A Varint uses 1 to 10 bytes to encode a 64-bit integer.
	- Each byte in the Varint (except the last one) has its most significant bit (MSB), the eighth bit, set to 1. This signals that more bytes follow.
	- The last byte has the MSB set to 0, signaling the end of the Varint.
	- The remaining 7 bits in each byte are used to store the payload data (the actual number).
- Benefit: An integer like 1 (which fits in 7 bits) is encoded in a single byte (0000 0001). A standard uint32 would always consume 4 bytes, wasting space when the number is small.

## 14.2. ZigZag Encoding for signed integers.
Varints are optimized for unsigned integers. If you encode signed integers (`int32`, `int64`) directly, a small negative number (like `-1`) would take the maximum 10 bytes because the high bit is set, forcing the encoder to use a full 64 bits to represent the negative sign.

ZigZag Encoding solves this by mapping signed numbers to unsigned numbers in a way that small negative numbers have a small encoded value, making them Varint-efficient.
- Mechanism: It maps the numbers zero and positive integers to even numbers, and negative integers to odd numbers.
	- $0 \rightarrow 0$
	- $-1 \rightarrow 1$
	- $1 \rightarrow 2$
	- $-2 \rightarrow 3$
	- $2 \rightarrow 4$
	- ...and so on.
- Benefit: A number like $-1$, which would otherwise be 10 bytes, is encoded as the unsigned value $1$, which takes only one byte as a Varint. The decoder knows to apply the ZigZag decoding logic after reading the Varint.

## 14.3. How Protobuf handles field tags and wire types binary-level.
Protobuf messages are serialized as a sequence of key-value pairs. The key is encoded first, followed by the value.
### The Key (Tag)
The key is a single Varint that packs two critical pieces of information: the Field Number and the Wire Type.

$$\text{Key} = (\text{Field Number} \ll 3) \mid \text{Wire Type}$$

- Field Number: The unique number assigned in the `.proto` file (e.g., `user_id = 1`).
- Wire Type: Indicates the data type and how the value should be encoded on the wire. This allows the parser to know how many bytes to read for the value.

| Wire Type | Value | Used For | Encoding |
|-----------|-------|----------|----------|
| Varint | 0 | int32, int64, uint32, uint64, bool, enum | Encoded using Base 128 Varint (and ZigZag if signed). |
| Fixed64 | 1 | fixed64, sfixed64, double | Always 8 bytes, little-endian. |
| Length-delimited | 2 | string, bytes, embedded messages, repeated fields | Encoded as (length as Varint, followed by the data bytes). |
| Fixed32 | 5 | fixed32, sfixed32, float | Always 4 bytes, little-endian. |

### The Value
The value immediately follows the key and is encoded according to the Wire Type specified in the key.

#### Example: A string field (`username = 5` of type `string`)
- Wire Type for string is 2 (Length-delimited).
- Key is encoded as a Varint: $(5 \ll 3) \mid 2 = 42$.
- The next bytes are the Value, encoded as a Varint length indicator (e.g., length of 6) followed by the actual data bytes (`"fedora"`).

This structure enables forward/backward compatibility: if an old client encounters a key corresponding to an unknown field number, the client can use the Wire Type embedded in the key to correctly skip the value, preventing parsing errors.
# Chapter 5: Server Streaming RPC
## 5.1. Use cases: Real-time feeds, large dataset downloads.
In a Server Streaming RPC, the client sends a single request to the server, and the server responds with a sequence of messages (a stream). The client reads from the stream until the server signals completion. This pattern is ideal for tasks where a single trigger initiates a long-running, continuous data flow.

### Primary Use Cases:
- Real-time Data Feeds: Sending continuous updates, such as stock prices, cryptocurrency quotes, sensor readings (IoT), or live scoreboards.
- Large Dataset Downloads: Retrieving a large number of records from a database or a file in manageable chunks without holding the entire dataset in server memory at once.
- Progress Tracking: Sending periodic status updates or logs back to the client during a long-running background job.

## 5.2. Defining stream in the return type.
To define a Server Streaming RPC, you must use the `stream` keyword before the response message type in your `.proto` file. The request remains a single message.

`proto/ticker.proto` (Conceptual Snippet)
```protobuf
service TickerService {
  // The stream keyword indicates a sequence of StockPrice messages will be sent back.
  rpc GetStockPrices (TickerRequest) returns (stream StockPrice);
}

message TickerRequest {
  string symbol = 1;
}

message StockPrice {
  string symbol = 1;
  double price = 2;
  int64 timestamp = 3;
}
```
## Polyglot Implementation
## 5.3. Go: Sending messages into the stream object.
In Go, the server's streaming method is generated with a special `ServerStream` argument. The implementation must use the `Send()` method on this stream object repeatedly inside a loop.

### Go Server Concept:
The generated method signature looks like this: `func (s *server) GetStockPrices(req *pb.TickerRequest, stream pb.TickerService_GetStockPricesServer) error`

```go
// Go Server implementation (Conceptual)
func (s *server) GetStockPrices(req *pb.TickerRequest, stream pb.TickerService_GetStockPricesServer) error {
	symbol := req.GetSymbol()
	
	for i := 0; i < 10; i++ {
		// 1. Create the message
		price := generateRandomPrice(symbol) 
		
		// 2. Send the message into the stream
		if err := stream.Send(price); err != nil {
			// Handle client disconnection or stream error
			return err 
		}
		time.Sleep(1 * time.Second)
	}
	// The function returning 'nil' signals the stream completion to the client.
	return nil
}
```
The Go client uses a loop to call the generated `Recv()` method until it receives the end-of-file error (`io.EOF`), indicating the stream is closed by the server.

## 5.4. C++: Using ServerWriter loop.
In C++, the streaming method is passed a special pointer to a `ServerWriter` object, which is used to push messages to the client.

### C++ Server Concept:
The method signature is: `Status GetStockPrices(ServerContext* context, const TickerRequest* request, ServerWriter<StockPrice>* writer)`

```c++
// C++ Server implementation (Conceptual)
Status CalculatorServiceImpl::GetStockPrices(
    ServerContext* context, 
    const TickerRequest* request, 
    ServerWriter<StockPrice>* writer) {
        
    for (int i = 0; i < 10; i++) {
        StockPrice price = generateRandomPrice(request->symbol());
        
        // Use the Writer object to push the message
        writer->Write(price);
        
        // Check if the context was cancelled (client disconnected)
        if (context->IsCancelled()) {
            return Status::CANCELLED;
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
    // Returning OK signals completion.
    return Status::OK;
}
```
## 5.5. Python: Using generators (`yield`) for responses.
In Python, the server implementation for a Server Streaming RPC is implemented using a generator function. Instead of returning a single message, the function uses the `yield` keyword to stream messages back to the client.

### Python Server Concept:
```python
# Python Server Servicer implementation (Conceptual)
class TickerServicer(rpc.TickerServiceServicer):
    
    # The method becomes a generator
    def GetStockPrices(self, request, context):
        symbol = request.symbol
        
        for i in range(10):
            price_message = pb.StockPrice(
                symbol=symbol,
                price=generate_random_price(),
                timestamp=int(time.time())
            )
            # Use 'yield' to send the message to the client
            yield price_message
            time.sleep(1)
        
        # The generator function finishing signals the end of the stream.
```
## 5.6. [Exercise: Build a "Stock Ticker" that streams random prices every second.](5-excercise.md)
Task: Implement the `GetStockPrices` service from the conceptual `ticker.proto`.

- Server: Implement the server in Go to stream 10 random prices for a requested symbol (e.g., "TSLA"), pausing 1 second between each.
- Client: Implement the client in Python to call the service and print each price as it arrives.
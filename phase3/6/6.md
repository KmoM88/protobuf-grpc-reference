# Chapter 6: Client Streaming RPC (Many Requests, One Response)
The Client Streaming RPC is the inverse of Server Streaming. The client sends a sequence of messages (a stream) to the server, and after the client finishes sending, the server processes all the received data and sends back a single response.

## 6.1. Use cases: File uploads, IoT sensor ingestion.
This pattern is highly effective when a client needs to deliver a large or indefinite amount of data to the server without holding it all in memory at once.

### Primary Use Cases:
- File Uploads (Chunking): Sending large files (images, videos, documents) in sequential, smaller data chunks. This prevents network timeouts and allows the server to process data incrementally.
- IoT Sensor Ingestion: Sending a batch of sensor readings accumulated over time (e.g., temperature, pressure logs) from a device to the server in a single RPC call.
- Batch Command Processing: Sending a list of operations or requests that the server should execute collectively before returning a final summary status.

## 6.2. Defining `stream` in the argument type.
To define a Client Streaming RPC, you must use the `stream` keyword before the request message type in your `.proto` file. The response remains a single message.

`proto/uploader.proto` (Conceptual Snippet)
```protobuf
service UploaderService {
  // The stream keyword indicates the client will send a sequence of ImageChunk messages.
  rpc UploadImage (stream ImageChunk) returns (UploadSummary);
}

message ImageChunk {
  bytes data = 1;
}

message UploadSummary {
  int32 total_chunks = 1;
  int64 total_bytes = 2;
}
```
## Polyglot Implementation
## 6.3. Go: Using `Recv()` inside a loop until EOF.
In Go, the server's method is passed a special `ServerStream` object. The server must manually loop, calling the `Recv()` method until it encounters the `io.EOF` (End Of File) error, which signals the client has finished sending data.

### Go Server Concept:
The generated method signature looks like this: func (s *server) UploadImage(stream pb.UploaderService_UploadImageServer) error

```go
// Go Server implementation (Conceptual)
func (*server) UploadImage(stream pb.UploaderService_UploadImageServer) error {
    var totalBytes int64
    var totalChunks int32
    
    // Loop until the stream is closed by the client
    for {
        chunk, err := stream.Recv()
        
        if err == io.EOF {
            // Client finished sending. Process and return the final response.
            summary := &pb.UploadSummary{
                TotalChunks: totalChunks,
                TotalBytes: totalBytes,
            }
            // Send the single final response and return nil to close the server method.
            return stream.SendAndClose(summary)
        }
        if err != nil {
            return err // Handle other errors (network, timeout)
        }
        
        // Process the received chunk
        chunkSize := len(chunk.GetData())
        totalBytes += int64(chunkSize)
        totalChunks++
    }
}
```
## 6.4. C++: Using ServerReader to aggregate data.
In C++, the server method receives a pointer to a `ServerReader` object and a pointer to the single response message. The server uses the reader's `Read()` method in a loop to consume the client's stream.

### C++ Server Concept:
The method signature is: `Status UploadImage(ServerContext* context, ServerReader<ImageChunk>* reader, UploadSummary* response)`

```c++
// C++ Server implementation (Conceptual)
Status UploaderServiceImpl::UploadImage(
    ServerContext* context, 
    ServerReader<ImageChunk>* reader, 
    UploadSummary* response) {
        
    ImageChunk chunk;
    int64_t totalBytes = 0;

    // Read the stream until the client closes it (Read() returns false)
    while (reader->Read(&chunk)) {
        totalBytes += chunk.data().size();
    }
    
    // Set the single final response message
    response->set_total_bytes(totalBytes);
    
    return Status::OK;
}
```
## 6.5. Python: Iterating over the request iterator.
In Python, the method receives the request argument as an iterator. The server simply iterates over this argument to consume the client's stream.

### Python Server Concept:

```python
# Python Server Servicer implementation (Conceptual)
class UploaderServicer(rpc.UploaderServiceServicer):
    
    # The 'request_iterator' is the stream of client messages
    def UploadImage(self, request_iterator, context):
        total_bytes = 0
        total_chunks = 0
        
        # Python automatically handles EOF when iterating over the stream
        for chunk in request_iterator:
            total_bytes += len(chunk.data)
            total_chunks += 1
            
        # Return the single final response
        return pb.UploadSummary(
            total_chunks=total_chunks, 
            total_bytes=total_bytes
        )
```
## 6.6. [Exercise: Build an "Image Uploader" (upload chunks, return total size).](6-excercise.md)
Task: Implement the UploadImage service.

- Protobuf: Define the service, ImageChunk (with bytes data), and UploadSummary.
- Server: Implement the server in Python to count the total bytes and total chunks received.
- Client: Implement the client in Go to generate 5 random chunks of data (e.g., 1024 bytes each) and stream them to the Python server. The client should print the final summary received from the server.
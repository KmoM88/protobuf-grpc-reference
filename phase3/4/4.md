# Chapter 4: Unary RPC (Simple Request-Response)
The Unary RPC is the most common and simplest form of gRPC call. It functions identically to a typical HTTP request: the client sends a single request message, and the server sends back a single response message.
## 4.1. Defining a Unary service in `.proto`.
A gRPC service is defined using the `service` keyword, containing `rpc` methods. Unary methods take one request message and return one response message, both of which must be defined using the `message` keyword.
`proto/calculator`
```protobuf
syntax = "proto3";

package calculator;

option go_package = "./calculatorpb";

// 1. Define the Service Interface
service CalculatorService {
  // A Unary RPC method: takes an Input, returns an Output.
  rpc Add (AddRequest) returns (AddResponse);
  rpc Subtract (SubtractRequest) returns (SubtractResponse);
}

// 2. Define Request Message
message AddRequest {
  int32 num1 = 1;
  int32 num2 = 2;
}

// 3. Define Response Message
message AddResponse {
  int32 result = 1;
}

// (Similar messages for Subtract will be used in the exercise)
message SubtractRequest {
  int32 num1 = 1;
  int32 num2 = 2;
}
message SubtractResponse {
  int32 result = 1;
}
```
## Polyglot Implementation
## 4.2. Go Implementation: Server & Client
The `protoc` compiler generates a Go interface (`CalculatorServiceServer`) that your server must implement, and a client stub (`CalculatorServiceClient`) for making calls.

### Go Server (`go/server/main.go`)
The server needs to implement the generated `Add` method and handle the request using `context.Context`.

```go
package main

// Import the generated protobuf code
import (
	"context"
	"log"
	"net"

	pb "./calculatorpb"
	"google.golang.org/grpc"
)

type server struct {
	pb.UnimplementedCalculatorServiceServer
}

// Implement the Unary RPC method defined in the .proto file
func (*server) Add(ctx context.Context, req *pb.AddRequest) (*pb.AddResponse, error) {
	log.Printf("Received Add request: %v", req)
	
	// Access data from the request message
	result := req.GetNum1() + req.GetNum2()
	
	// Create and return the response message
	res := &pb.AddResponse{
		Result: result,
	}
	return res, nil
}

func main() {
	lis, err := net.Listen("tcp", ":50051")
	if err != nil {
		log.Fatalf("failed to listen: %v", err)
	}
	// Create a new gRPC server instance
	s := grpc.NewServer()
	// Register the implemented service
	pb.RegisterCalculatorServiceServer(s, &server{})
	
	log.Println("Go Server listening on :50051")
	if err := s.Serve(lis); err != nil {
		log.Fatalf("failed to serve: %v", err)
	}
}
```
### Go Client Concepts
To make a call, the client must first establish a connection (Channel) and then instantiate the client stub:
- Channel Creation: Use `grpc.Dial("localhost:50051", grpc.WithTransportCredentials(insecure.NewCredentials()))` to create a connection.
- Client Stub: Instantiate the client using `pb.NewCalculatorServiceClient(conn)`.
- Call: Call the client method `c.Add(ctx, req)`. The `context.Context` is crucial here for handling timeouts and cancellation.

## 4.3. C++ Implementation: 
In C++, you must inherit from the generated Service Base Class and implement its virtual methods.
### C++ Server (`cpp/calculator_server.cc` - Conceptual)

```c++
#include <grpc++/grpc++.h>
#include "calculator.grpc.pb.h"

// 1. Inherit from the generated base class
class CalculatorServiceImpl final : public calculator::CalculatorService::Service {
  
  // 2. Override the virtual Unary method
  grpc::Status Add(
      grpc::ServerContext* context, 
      const calculator::AddRequest* request, 
      calculator::AddResponse* response) override {
    
    // Access data using generated getters
    int32_t result = request->num1() + request->num2();
    
    // Set response data using generated setters
    response->set_result(result);
    
    // 3. Return grpc::Status::OK for success
    return grpc::Status::OK; 
  }
  
  // ... implement Subtract ...
};
```
- `grpc::ServerContext`: Holds metadata, deadlines, and authentication information for the current RPC call.
- `grpc::Status`: The C++ return type for all service methods. Returning `grpc::Status::OK` indicates success. Any other status code (e.g., `UNAUTHENTICATED`, `NOT_FOUND`) will be sent back to the client as an error.
- Memory Management: Protobuf messages in C++ are typically handled by the library using internal memory management. However, when dealing with `string` or `bytes`, it is essential to use the `set_allocated_...` or `mutable_...` accessors for advanced scenarios to avoid unnecessary copying.

## 4.4. Python Implementation: Server & Client
Python uses the concept of a Servicer—a class that implements the business logic—and a standard Python `grpc.server` which runs the methods asynchronously in a thread pool.

### Python Server (`python/server.py`)

```python
import grpc
import time
from concurrent import futures

# Import generated modules (protoc creates *_pb2 and *_pb2_grpc)
from calculator import calculator_pb2 as pb
from calculator import calculator_pb2_grpc as rpc

class CalculatorServicer(rpc.CalculatorServiceServicer):
    
    # The signature matches the generated function
    def Add(self, request, context):
        print(f"Received Add request: {request.num1} + {request.num2}")
        result = request.num1 + request.num2
        
        # Instantiate and return the response message
        return pb.AddResponse(result=result)

def serve():
    # Start the gRPC server on a ThreadPool executor
    server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))
    # Register the Servicer implementation
    rpc.add_CalculatorServiceServicer_to_server(CalculatorServicer(), server)
    
    server.add_insecure_port('[::]:50051')
    server.start()
    print("Python Server listening on :50051")
    
    # Keep the main thread alive until shutdown
    try:
        while True:
            time.sleep(86400) 
    except KeyboardInterrupt:
        server.stop(0)

if __name__ == '__main__':
    serve()
```

## 4.5. Exercise: Build a "Calculator Service"
The exercise is now defined: Use the `calculator.proto` from 4.1 to implement the `Add` and `Subtract` RPCs:
| Component | Language | Task |
|-----------|----------|------|
| Server | Go | Implement `Add` and `Subtract` methods and start the server. |
| Client | Python| Create a client to connect to the Go server and make a call to `Add(10, 5)` and `Subtract(20, 7)`. |

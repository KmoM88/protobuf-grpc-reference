# Chapter 7: Bidirectional Streaming RPC (Many Requests, Many Responses)
The Bidirectional Streaming RPC is the most versatile gRPC type, allowing full-duplex communication. Both the client and the server can send a stream of messages to each other simultaneously and independently over a single, long-lived TCP connection.

## 7.1. Use cases: Chat apps, Multiplayer games, Live synchronization.
This pattern is mandatory for scenarios where both sides need to send and receive data at any time, with message order being crucial or concurrency being necessary.

## Primary Use Cases:
- Chat Applications: The most classic example; users send messages while concurrently receiving messages from others.
- Multiplayer Games: Sending player actions (client stream) and receiving immediate, continuous game state updates (server stream).
- Live Synchronization: Tools like collaborative text editors where changes are streamed instantly in both directions.

## 7.2. Go: Handling independent `Send()` and `Recv()` in goroutines.
In Go, both the client and the server receive a single `Stream` object that implements both the `Send()` and `Recv()` methods. Since reading (`Recv()`) is a blocking operation, the server must use separate goroutines to handle the incoming client messages and the outgoing server responses concurrently.

### Go Server Concept:
```go
// Generated method signature:
// func (s *server) JoinChat(stream pb.ChatService_JoinChatServer) error
func (*server) JoinChat(stream pb.ChatService_JoinChatServer) error {
    // Goroutine 1: Read client messages (must be blocking loop)
    go func() {
        for {
            msg, err := stream.Recv()
            // ... process EOF and errors ...
            // Broadcast msg to other clients
        }
    }()

    // Goroutine 2 (Main Thread): Wait for a signal to close the connection,
    // or handle global broadcast logic.
    <-waitc // Wait for something to happen or timeout
    return nil // Returning nil closes the stream
}
```
## 7.3. C++: Using `ServerReaderWriter`.
In C++, the `ServerReaderWriter` object acts as the interface for both reading (`Read()`) the client's stream and writing (`Write()`) the server's stream.

### C++ Server Concept:
The method signature is: `Status JoinChat(ServerContext* context, ServerReaderWriter<ChatMessage, ChatMessage>* stream)`

```c++
// C++ Server implementation (Conceptual)
Status ChatServiceImpl::JoinChat(
    ServerContext* context, 
    ServerReaderWriter<ChatMessage, ChatMessage>* stream) {
        
    ChatMessage request;
    
    // In C++, often requires a thread model or asynchronous API for true concurrency,
    // otherwise the main thread is blocked waiting on stream->Read().
    
    // Simple synchronous implementation:
    while (stream->Read(&request)) {
        // Process request, then immediately Write back if needed.
        // stream->Write(response); 
    }
    
    return Status::OK;
}
```
## 7.4. Python: Consuming an iterator while yielding responses simultaneously.
In Python, the server implementation is often structured similarly to Client Streaming, but the key is that the body of the function must `yield` responses back while the `request_iterator` is being consumed.

### Python Server Concept:
```python
# Python Server Servicer implementation (Conceptual)
class ChatServicer(rpc.ChatServiceServicer):
    
    def JoinChat(self, request_iterator, context):
        
        # This setup is problematic in Python for concurrent Bidirectional streams 
        # unless handled asynchronously (Async gRPC). For basic examples,
        # we often rely on concurrent processing inside the loop.
        
        for request in request_iterator:
            # Process incoming message
            
            # Yield a response immediately (or based on some event)
            # yield response_message 
            pass
```
## 7.5. [Exercise: Build a "Chat Room" (Go Server, Python & Go Clients).](7-excercise.md)
Task: Implement a minimal ChatService that handles two concurrent clients.

- Protobuf: Define ChatService with an RPC JoinChat that takes and returns a stream of ChatMessage (with user_id and text).
- Server: Implement the server in Go. The server must:
	1. Broadcast every received message to all currently connected clients (including the sender).
	2. Use a global state (e.g., a map of channels) and goroutines to manage concurrent connections and message broadcasting.

- Clients:
	1. Implement a client in Go to send and receive messages concurrently.
	2. Implement a client in Python to send and receive messages concurrently (using threads).
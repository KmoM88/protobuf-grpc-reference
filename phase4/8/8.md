# Chapter 8: Schema Design & Evolution
Schema design and management are perhaps the most important non-functional aspects of using Protobuf and gRPC. Proper schema evolution ensures backward and forward compatibility across distributed microservices.
## 8.1. Google's Style Guide for `.proto`.
Google maintains a comprehensive style guide for Protobuf definitions, designed to maximize readability and consistency across large codebases. Adhering to these conventions helps maintain interoperability, especially in polyglot environments.
| Element | Style Guide | Example |
|---------|--------------|---------|
| Files | Lowercase with underscores. | `user_profile.proto` |
| Packages | Lowercase, matching file name structure. | `package users.v1;` |
| Messages | PascalCase (CamelCase starting with a capital letter). | `UserProfile` |
| Fields | Lowercase with underscores. | `first_name` |
| Services | PascalCase (ending with Service is common, but not mandatory). | `BillingService` |
| Enums | PascalCase. | `SubscriptionStatus` |
| Enum Values | ALL_CAPS with underscores (prefixed by the enum name). | `SUBSCRIPTION_STATUS_ACTIVE` |

## 8.2. Field Numbering Rules: Why you never reuse numbers.
Protobuf does not use field names when serializing data; it uses the field numbers (tags). These numbers are the immutable identifiers on the wire.
- Rule: Once a field number is used and released (deleted from the schema), it must never be reused for a new field in the same message definition.
- Why: If you reuse a number, an old client expecting old_field = 3 will incorrectly parse data sent by a new server containing new_field = 3. This leads to silent data corruption and hard-to-debug system failures.
- Best Practice: Start field numbers at 1. Numbers 1 through 15 take less space on the wire (one byte for the tag), making them ideal for frequently sent fields. Reserve higher numbers for less frequent fields.

## 8.3. Backward & Forward Compatibility strategies.
Compatibility is key to rolling out new versions of services without causing downtime or errors with older clients/servers.
| Compatibility Type | Description | Strategy |
|-------------------|-------------|----------|
| Backward | New Server communicating with Old Client. | Old clients must be able to read data from the new server. New fields added by the server are simply ignored by the old client. Old clients must treat new fields as unknown. |
| Forward | Old Server communicating with New Client. | New clients must be able to read data from the old server. New fields used by the client must be optional. If the old server doesn't send the new field, the new client uses the default value. |

### Non-Breaking Changes (Always Safe):
- Adding a new field (must be optional in Protobuf 2, default in Protobuf 3).
- Adding a new value to an enum.
### Breaking Changes (Must Be Avoided):
- Changing the field number of an existing field.
- Changing the type of a field (e.g., `int32` to `string`).
- Renaming a field (safe at the code level, but confusing; usually reserved instead).
- Removing a field (if not reserved, leads to reuse risk).

## 8.4. Using reserved fields.
To strictly enforce the "never reuse numbers" rule and prevent conflicts, Protobuf allows you to mark specific field numbers or names as `reserved`.

```protobuf
message User {
    // These numbers can never be used again
    reserved 4, 15 to 19; 
    
    // These names can never be used again
    reserved "old_email", "temp_id";
    
    int32 id = 1;
    string name = 2;
    string email = 3;
}
```
If a developer tries to use a reserved number or name, the Protobuf compiler will throw an error, preventing accidental data corruption.

## 8.5. Well-Known Types (Timestamp, Duration, Struct).
Protobuf provides a set of standard, frequently used message types (Well-Known Types, WKTs) that are included in the Google Protobuf repository. Using these ensures consistency and better interoperability, as every language binding provides standard wrappers for them.
To use them, you must `import "google/protobuf/[type].proto";`.

| Well-Known Type | Purpose | Native Mapping (Example Python) |
|-----------------|---------|---------------------------------|
| Timestamp | Represents a point in time (seconds and nanos since epoch). | `datetime.datetime` object |
| Duration | Represents a length of time (seconds and nanos). | `datetime.timedelta` object |
| Empty | A message with no fields (useful for methods that take no arguments). | `None` or an empty object |
| Struct | Represents a dynamically typed object (JSON object equivalent). | Dictionary (`dict`) |
| Any | Allows embedding a message of arbitrary type, dynamically. | Message object |

### Example Usage:

```protobuf
import "google/protobuf/timestamp.proto";
import "google/protobuf/duration.proto";

message AuditEvent {
    google.protobuf.Timestamp event_time = 1;
    google.protobuf.Duration processing_latency = 2;
}
```
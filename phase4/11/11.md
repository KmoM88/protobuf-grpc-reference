# Chapter 11: Interceptors (Middleware)
Interceptors act as middleware, allowing developers to inject logic that executes before, after, or around the main gRPC RPC handler function. They are crucial for implementing cross-cutting concerns (like logging, authentication, and monitoring) without cluttering the application logic.

Interceptors exist for both Unary (single request/response) and Stream (streaming) RPC types, and can be applied on both the Client and Server sides.

## 11.1. Go: `UnaryServerInterceptor` and `StreamServerInterceptor`.
In Go, interceptors are defined as functions that wrap the main RPC call. They are applied when the gRPC server is created.

### `UnaryServerInterceptor`
This is a function type that takes the Go `context.Context`, the request payload (`interface{}`), a `grpc.UnaryServerInfo` struct (containing method details), and the main RPC handler function (`grpc.UnaryHandler`).

```go
// Go UnaryServerInterceptor function signature:
func loggingInterceptor(
    ctx context.Context,
    req interface{},
    info *grpc.UnaryServerInfo,
    handler grpc.UnaryHandler,
) (resp interface{}, err error) {
    // Logic BEFORE handler execution (e.g., logging metadata, authentication)
    log.Printf("Method: %s started", info.FullMethod)

    // Call the next handler in the chain (or the final RPC function)
    resp, err = handler(ctx, req) 

    // Logic AFTER handler execution (e.g., logging error codes, metrics)
    log.Printf("Method: %s finished with error: %v", info.FullMethod, err)

    return resp, err
}
```

### `StreamServerInterceptor`
This handles streaming RPCs (Client, Server, and Bidirectional). It takes the `context.Context`, a `grpc.ServerStream`, and the stream handler function (`grpc.StreamHandler`). The interceptor must return a customized `grpc.ServerStream` to wrap the `Recv()` and `Send()` methods, injecting logic around each stream operation.

## 11.2. Python: Client and Server interceptors.
In Python, interceptors are typically implemented as classes that inherit from grpc.ServerInterceptor or grpc.ClientInterceptor.

### Server Interceptor
The server interceptor implements the `intercept_service` method, which is responsible for wrapping the service method handlers.

```python
# Python ServerInterceptor (Conceptual)
class AuthInterceptor(grpc.ServerInterceptor):
    def intercept_service(self, continuation, handler_call_details):
        # Logic to check authentication tokens in context metadata
        
        # If authentication fails, return a handler that throws an UNAUTHENTICATED error.
        # If authentication succeeds, pass control to the next interceptor/handler.
        return continuation(handler_call_details) 
```
### Client Interceptor
The client interceptor implements the `intercept_unary_unary` or `intercept_stream_stream` methods to inject logic before or after the client makes the RPC call.

## 11.3. C++: `AuthMetadataProcessor` and generic interceptors.
C++ provides specialized interfaces for intercepting calls:

- `AuthMetadataProcessor`: This is a dedicated, simpler interface primarily used for handling incoming authentication metadata (like JWTs) on the server side.
- Generic Interceptors (`grpc::experimental::Interceptor`): These offer a lower-level, more complex way to inject logic for both clients and servers, providing hooks for every stage of the RPC lifecycle.

## 11.4. Use cases: Logging, Tracing, Authentication validation.
Interceptors are essential for any production-grade system because they centralize logic that applies to all or most RPC endpoints.
- Authentication Validation: Extracting and validating JWTs from metadata, terminating the request early if invalid (as discussed in Chapter 10).
- Logging and Metrics: Recording the start and end time of every RPC, logging request parameters, and capturing latency metrics.
- Tracing (OpenTelemetry): Starting and ending distributed tracing spans (e.g., correlation IDs) that track a request across multiple microservices.
- Rate Limiting: Checking a client's API key against a quota system and returning `RESOURCE_EXHAUSTED` if limits are exceeded.